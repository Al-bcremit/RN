{"version":3,"names":["NativeReanimatedModule","shouldBeUseWeb","USE_STUB_IMPLEMENTATION","_shareableCache","WeakMap","_shareableFlag","Symbol","registerShareableMapping","shareable","shareableRef","set","makeShareableShadowNodeWrapper","shadowNodeWrapper","adoptedSNW","makeShareableClone","makeShareableCloneRecursive","value","type","cached","get","undefined","toAdapt","Array","isArray","map","element","__workletHash","key","Object","entries","__DEV__","freeze","adopted","makeShareableCloneOnUIRecursive","cloneRecursive","_makeShareableClone","makeShareable","handle","__init"],"sources":["shareables.ts"],"sourcesContent":["import NativeReanimatedModule from './NativeReanimated';\nimport { ShareableRef } from './commonTypes';\nimport { shouldBeUseWeb } from './PlatformChecker';\n\n// for web/chrome debugger/jest environments this file provides a stub implementation\n// where no shareable references are used. Instead, the objects themselves are used\n// instead of shareable references, because of the fact that we don't have to deal with\n// runnning the code on separate VMs.\nconst USE_STUB_IMPLEMENTATION = shouldBeUseWeb();\n\nconst _shareableCache = new WeakMap<\n  Record<string, unknown>,\n  ShareableRef<any> | symbol\n>();\n// the below symbol is used to represent a mapping from the value to itself\n// this is used to allow for a converted shareable to be passed to makeShareableClone\nconst _shareableFlag = Symbol('shareable flag');\n\nexport function registerShareableMapping(\n  shareable: any,\n  shareableRef?: ShareableRef<any>\n): void {\n  if (USE_STUB_IMPLEMENTATION) {\n    return;\n  }\n  _shareableCache.set(shareable, shareableRef || _shareableFlag);\n}\n\nexport function makeShareableShadowNodeWrapper<T>(shadowNodeWrapper: T): T {\n  const adoptedSNW =\n    NativeReanimatedModule.makeShareableClone(shadowNodeWrapper);\n  registerShareableMapping(shadowNodeWrapper, adoptedSNW);\n  return shadowNodeWrapper;\n}\n\nexport function makeShareableCloneRecursive<T>(value: any): ShareableRef<T> {\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  // This one actually may be worth to be moved to c++, we also need similar logic to run on the UI thread\n  const type = typeof value;\n  if ((type === 'object' || type === 'function') && value !== null) {\n    const cached = _shareableCache.get(value);\n    if (cached === _shareableFlag) {\n      return value;\n    } else if (cached !== undefined) {\n      return cached as ShareableRef<T>;\n    } else {\n      let toAdapt: any;\n      if (Array.isArray(value)) {\n        toAdapt = value.map((element) => makeShareableCloneRecursive(element));\n      } else if (type === 'function' && value.__workletHash === undefined) {\n        // this is a remote function\n        toAdapt = value;\n      } else {\n        toAdapt = {};\n        for (const [key, element] of Object.entries(value)) {\n          toAdapt[key] = makeShareableCloneRecursive(element);\n        }\n      }\n      if (__DEV__) {\n        // we freeze objects that are transformed to shareable. This should help\n        // detect issues when someone modifies data after it's been converted to\n        // shareable. Meaning that they may be doing a faulty assumption in their\n        // code expecting that the updates are going to automatically populate to\n        // the object sent to the UI thread. If the user really wants some objects\n        // to be mutable they should use share values instead.\n        Object.freeze(value);\n      }\n      const adopted = NativeReanimatedModule.makeShareableClone(toAdapt);\n      _shareableCache.set(value, adopted);\n      _shareableCache.set(adopted, _shareableFlag);\n      return adopted;\n    }\n  }\n  return NativeReanimatedModule.makeShareableClone(value);\n}\n\nexport function makeShareableCloneOnUIRecursive<T>(value: T): ShareableRef<T> {\n  'worklet';\n  if (USE_STUB_IMPLEMENTATION) {\n    // @ts-ignore web is an interesting place where we don't run a secondary VM on the UI thread\n    // see more details in the comment where USE_STUB_IMPLEMENTATION is defined.\n    return value;\n  }\n  function cloneRecursive<T>(value: T): ShareableRef<T> {\n    const type = typeof value;\n    if ((type === 'object' || type === 'function') && value !== null) {\n      let toAdapt: any;\n      if (Array.isArray(value)) {\n        toAdapt = value.map((element) => cloneRecursive(element));\n      } else {\n        toAdapt = {};\n        for (const [key, element] of Object.entries(value)) {\n          toAdapt[key] = cloneRecursive(element);\n        }\n      }\n      if (__DEV__) {\n        // See the reasoning behind freezing in the other comment above.\n        Object.freeze(value);\n      }\n      return _makeShareableClone(toAdapt);\n    }\n    return _makeShareableClone(value);\n  }\n  return cloneRecursive(value);\n}\n\nexport function makeShareable<T>(value: T): T {\n  if (USE_STUB_IMPLEMENTATION) {\n    return value;\n  }\n  const handle = makeShareableCloneRecursive({\n    __init: () => {\n      'worklet';\n      return value;\n    },\n  });\n  registerShareableMapping(value, handle);\n  return value;\n}\n"],"mappings":"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"}